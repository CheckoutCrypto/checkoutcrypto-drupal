<?php

//error_reporting(~0); ini_set('display_errors', 1);

/**
 * @file
 * cc payment method.
 *
 * @author checkoutcrypto - dev@checkoutcrypto.com
 **/
function uc_cc_checkout_complete() {
  if (empty($_SESSION['cart_order']) || empty($_SESSION['uc_checkout'][$_SESSION['cart_order']]['do_complete'])) {
    drupal_goto('cart');
  }

  $order = uc_order_load(intval($_SESSION['cart_order']));

  if (empty($order)) {
    // Display messages to customers and the administrator if the order was lost.
    drupal_set_message(t("We're sorry.  An error occurred while processing your order that prevents us from completing it at this time. Please contact us and we will resolve the issue as soon as possible."), 'error');
    watchdog('uc_cart', 'An empty order made it to checkout! Cart order ID: @cart_order', array('@cart_order' => $_SESSION['cart_order']), WATCHDOG_ERROR);
    drupal_goto('cart');
  }

  $build = uc_cart_complete_sale($order, variable_get('uc_new_customer_login', FALSE));
  unset($_SESSION['uc_checkout'][$order->order_id], $_SESSION['cart_order']);

  // Add a comment to let sales team know this came in through the site.
  uc_order_comment_save($order->order_id, 0, t('Order created through website.'), 'admin');

  $page = variable_get('uc_cart_checkout_complete_page', '');
  if (!empty($page)) {
    drupal_goto($page);
  }

  return $build;
}
/**
 * Checkout crypto settings form.
 */
function uc_cc_settings_form() {
  $form = array();

  $form['server'] = array(
    '#type' => 'fieldset',
    '#title' => t('Server settings'),
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
  );
  $form['server']['uc_cc_server'] = array(
    '#type' => 'radios',
    '#title' => t('Remote server'),
    '#default_value' => variable_get('uc_cc_server', "api.checkoutcrypto.com"),
    '#options' => array('api.checkoutcrypto.com' => 'api.checkoutcrypto.com'),
  );
  $form['server']['uc_cc_server_apikey'] = array(
    '#type' => 'textfield',
    '#title' => t('API key'),
    '#default_value' => variable_get('uc_cc_server_apikey', ''),
    '#description' => t('Your !link1 API key. !link2',
      array('!link1'=> '<a href="http://checkoutcrypto.com">'.t('checkoutcrypto.com').'</a>','!link2'=> '<a href="http://checkoutcrypto.com/docs/beginner">'.t('What\'s this?').'</a>')),
    '#required' => TRUE,
  );

    $form['server']['actions']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Refresh Coins'),
	'#ajax' => array(
            'callback' => 'cc_refresh_callback',),
  );

  $form['#validate'][] = 'uc_cc_settings_form_validate';

  return system_settings_form($form);
}

/**
 * Validate cc payment method settings.
 * @param unknown_type $form
 * @param unknown_type $form_state
 */
function uc_cc_settings_form_validate($form, &$form_state) {

  $c = $form_state['values']['uc_cc_server'];
  if ($c != 'api.checkoutcrypto.com') {
    form_set_error('uc_cc_server', t('Invalid remote server specified'));
  }

  $c = $form_state['values']['uc_cc_server_apikey'];
  if ($c == NULL) {
    form_set_error('uc_cc_server', t('API key is a required field!'));
  }else{
 	ccApiRefreshCoins();
	}


  if (!count(form_get_errors())) {
    // TODO

  /*if (TRUE !== ($fault = $cc_client->can_connect())) {
      form_set_error('', t("Unable to communicate with the selected checkoutcrypto.com server."));
    }*/
  }

}

/*******************************************************************************
 * Hook Functions (Ubercart)
 ******************************************************************************/

/**
 * Implementation of hook_mail_alter().
 * @param array $&message
 *
 * Produces an altered email for 'uc_order_action-mail'
 * which includes the cc address to send payments to
 * for the order.
 */
function uc_cc_mail_alter(&$message) {
  // Set this to debug mails on local disk.
  if ($message['id'] == 'uc_order_action-mail') {
    $order = $message['params']['replacements']['uc_order'];

    $result = db_select('uc_payment_cc')
      ->fields('uc_payment_cc', array(
        'order_id',
        'cc_coinname_short',
        'cc_coinname_full',
        'cc_coin_amount',
        'cc_address',
        'cc_pay_status',
        'cc_queue_id',
        'cc_pay_amount',
        'timestamp'))
      ->condition('order_id', $order->order_id, '=')
      ->execute()
      ->fetchAssoc();

    $message['body'][] = t("\n--\nPayment is sent to address: ") . t($result['cc_address']);
  }
}

/**
 * Implementation of hook_payment_method().
 */
function uc_cc_uc_payment_method() {

  $title = theme('image', array(
    'path' => drupal_get_path('module', 'uc_cc') . '/images/logo.jpg',
    'attributes' => array('class' => array('uc-cc')),
  )) . ' ' . t('Checkout Crypto');

  $methods['checkoutcrypto'] = array(
    'id' => 'checkoutcrypto',
    'name' => t('Checkout Crypto'),
    'title' => $title,
    'desc' => t('Pay with Checkout Crypto.'),
    'callback' => 'uc_payment_method_cc',
    'redirect' => 'cc_payment_form',
    'weight' => 1,
    'no_gateway' => TRUE,
    'checkout' => TRUE,
  );
  return $methods;
}

/**
 * Payment form to override 
 */
function cc_payment_form($form, &$form_state) {

  ctools_include('modal');
  ctools_modal_add_js();

  $form['actions']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Proceed to payment'),
	'#ajax' => array(
            'callback' => 'uc_cc_callback',),
  );

  return $form;

}


/**
 * Form for checkout crypto payment
 */
function uc_cc_form($form, $form_state) {
	 $coins = getAvailableCoins();

    if(isset($_SESSION['cart_order'])) { //locate the current order from the session
        $order = uc_order_load(intval($_SESSION['cart_order']));
     } else {
        watchdog('uc_cc_form', 'Could not load current order: !fault', $e->getMessage());
     }

    global $base_path;
    $modp = drupal_get_path('module','uc_cc');
    $cc_class_sel = 'uc_cc_show';
    $cc_class_pay = 'uc_cc_hide';        

   // Initiate form and add wrappers
   $form = array();
   $form['wrapper_header'] = array('#markup' => t('<div id="cc-wrapper"><div id="cc-border">'));
   $form['wrapper_content'] = array('#markup' => t('<div id="cc_pay"></div>'));
   $form['uc_cc_payment_information'] = array(
     '#markup' => t('<p>Please select your preferred cryptocurrency to continue with payment</p>')
    );

   $form['uc_cc_coin_select_wrapper'] = array('#markup' => t('<div id="cc_coin_select_wrapper" class="'.$cc_class_sel.'">'));
   //Available coins
   foreach($coins as $coin){
       $coin_code = strtolower($coin['coin_code']);
	   $coin_image = $coin['coin_image'];
  	   $form['uc_cc_coin_select_'.$coin_code] = array('#markup' => t('<div id="cc_coin_'.$coin_code.'"></div>'));
       $form['uc_cc_coin_select_'.$coin_code] = array('#markup' => t('<div id="cc_coin_'.$coin_code.'"></div>'));
   }
   //Close coin select wrapper and open payment_processing_wrapper
   $form['uc_cc_coin_select_wrapper_end'] = array('#markup' => t('</div>'));
   $form['uc_cc_payment_processing_wrapper'] = array('#markup' => t('<div id="cc_payment_processing_wrapper" class="'.$cc_class_pay.'">'));

    
   $form['uc_cc_selected_coin'] = array(
       '#type' => 'hidden',
       '#value' => t(''),
       );

$order_failed = FALSE;
if(!($order_failed)) {
    $form['uc_cc_payment_address'] = array(
        '#type' => 'textfield',
        '#value' => t(''),
        '#attributes' => array('readonly' => 'readonly','size' => 50),
        '#prefix' => '<div id="uc_cc_payment_address_container">',
        '#suffix' => '</div>',
        );

    $form['uc_cc_payment_qr_address'] = array(
      '#markup' => '<div id="uc_cc_payment_qr_address_container"></div>'
    );

    $form['actions']['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Refresh'),
        '#ajax' => array(
            'callback' => 'uc_cc_form_submit',),
    );

    $form['uc_cc_progress_status'] = array(
      '#markup' => '<div id="cc_progress_status">This window will auto-refresh status until order is complete</div>',
    );
} else {
    $form['uc_cc_payment_information'] = array(
      '#markup' => '<p>Could not register order with Checkout Crypto. Please close this window and submit the order to try again. <small><a href="http://checkoutcrypto.com/support/help">Support link</a></p>'
    );
}
  $form['wrapper_end'] = array('#markup' => t('</div></div></div>'));
  return $form; 
}

/**
 * Implementation of hook_submit().
 */
function uc_cc_form_submit(&$form, &$form_state) {
    if(isset($_SESSION['cart_order'])) { //locate the current order from the session
        $order = uc_order_load(intval($_SESSION['cart_order']));
     } else {
        watchdog('uc_cc_form_submit', 'Could not load current order');
     }
    global $user;

    ctools_include('ajax');
    ctools_include('modal');
    ctools_add_js('ajax-responder');

    if(isset($form_state['input']['uc_cc_selected_coin'])) {
        $coin_selected = $form_state['input']['uc_cc_selected_coin'];
          if($coin_selected != NULL) {
              $coin_name_input_short = strtoupper(substr($coin_selected, 8, strlen($coin_selected)));
              if($order->cc_coinname_short == NULL OR $order->cc_coinname_short != $coin_name_input_short) {
                  $coins = getAvailableCoins();
                  foreach($coins as $coin){
                      $coin_code = strtoupper($coin['coin_code']);
                      $coin_name = $coin['coin_name'];
                      if($coin_name_input_short == $coin_code) {
                          $order->cc_coinname_full = $coin_name;
                          $order->cc_coinname_short = $coin_code;
                      }
                  }
              }
          }
    }
    $result = cc_order_status($order);
    //If order not found, create a new one
    if ($result === FALSE) {
      $order_info = uc_payment_method_cc('order-submit', $order);
      $coin_amount = $order_info['coin_amount'];
      $coin_name = $order_info['coin_name'];
      $coin_name_full = $order_info['coin_name_full'];
      $queue_id = $order_info['queue_id'];
      $pay_status = $order_inf['pay_status'];
    } else {
        //Check if customer has switched coin
        if(($order->cc_coinname_short != NULL) AND ($result['cc_coinname_short'] != $order->cc_coinname_short)) {
          $order_info = uc_payment_method_cc('order-submit', $order);
          $coin_amount = $order_info['coin_amount'];
          $coin_name = $order_info['coin_name'];
          $coin_name_full = $order_info['coin_name_full'];
          $queue_id = $order_info['queue_id'];
          $pay_status = $order_inf['pay_status'];
          $change_coin = TRUE;
        } else { //same
          $coin_amount = $result['cc_coin_amount'];
          $coin_name = $result['cc_coinname_short'];
          $coin_name_full = $result['cc_coinname_full'];
          $queue_id = $result['cc_queue_id'];
          $pay_status = $result['cc_pay_status'];
        }
   }
   //Check if payment has been received
   if(strtolower($pay_status) == 'payment_entered') {
        $form_state['values']['op'] = t('complete');
        $_SESSION['uc_checkout'][$_SESSION['cart_order']]['do_complete'] = TRUE;      

         //close modal and redirect to checkout page
        $commands[] = ctools_modal_command_dismiss();
        $commands[] = ctools_ajax_command_redirect('cart/checkout/complete');
        drupal_set_message('Your purchase is now complete. A receipt will be emailed to you');
   } else {
           //Add basic info and wrappers
           $form['uc_cc_coin_select_wrapper'] = array('#markup' => t('<div id="cc_coin_select_wrapper" class="uc_cc_hide">'));
           $form['uc_cc_payment_processing_wrapper'] = array('#markup' => t('<div id="cc_payment_processing_wrapper" class="uc_cc_show">'));
           $form['uc_cc_payment_information'] = array('#markup' => '<p>Selected currency:<strong> '.$coin_name_full.'</strong> <a id="cc_coin_reselect" style="cursor: pointer">Change</a><br>Please send <strong>'.$coin_name.' '.$coin_amount.'</strong> to the following address.</p>');
       if(isset($result['cc_address']) AND !($change_coin)) {
           $form['uc_cc_payment_address'] = array(
                '#type' => 'textfield',
                '#value' => t($result['cc_address']),
                '#attributes' => array('readonly' => 'readonly','size' => 50),
                '#prefix' => '<div id="uc_cc_payment_address_container">',
                '#suffix' => '</div>',
            );

           $url_qr_base = 'https://chart.googleapis.com/chart?cht=qr';
           $url_qr_args = '&chs=150';
           $url_qr_args .= '&choe=UTF8';
           $url_qr_args .= '&chld=L';
           $url_qr_args .= '&chl='.$result['cc_address'];
           $url_qr = $url_qr_base.$url_qr_args;
           $url_qr_output = '<img src="'.$url_qr.'">';

           $form['uc_cc_payment_qr_address'] = array(
               '#markup' => '<div id="uc_cc_payment_qr_address_container">'.$url_qr_output.'</div>'
           );
       }
   }
   $commands[] = ajax_command_replace('#cc-wrapper', drupal_render($form));
    print ajax_render($commands);
    drupal_exit();
}

/**
 * Ajax menu callback.
 */
function uc_cc_callback($ajax, $data) {

if(isset($_SESSION['cart_order'])) {
    $order = uc_order_load(intval($_SESSION['cart_order']));
} else {
    watchdog('uc_cc_callback', 'Could not load current order: !fault');
}
  if ($ajax) {
    ctools_include('ajax');
    ctools_include('modal');
    drupal_add_js('sites/all/modules/uc_cc/uc_cc.js', 'file');
    drupal_add_css('sites/all/modules/uc_cc/uc_cc.css', 'file');
    drupal_add_css('sites/all/modules/uc_cc/modal.css', 'file');

    $status = cc_order_status($order);
    if($status != FALSE || $status != NULL) {
        $cc_sel_coin = TRUE;
    } else {
        $cc_sel_coin = FALSE;
    }

    $form_state = array(
      'ajax' => TRUE,
      'title' => t('Checkout Crypto Payment Form'),
      'cc_sel_coin' => $cc_sel_coin,
    );

    $output = ctools_modal_form_wrapper('uc_cc_form', $form_state);

    print ajax_render($output);
    drupal_exit();
  }
  else {
    return drupal_get_form('uc_cc_form');
  }
}

/**
 * Implementation of hook_menu().
 */
function uc_cc_menu() {
  $items['uc_cc/%ctools_js'] = array(
    'page callback' => 'uc_cc_callback',
    'page arguments' => array(1),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
$items['cart/checkout/complete'] = array(
    'title' => 'Order complete',
    'description' => 'Display information upon completion of an order.',
    'page callback' => 'uc_cc_checkout_complete',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  return $items;
}
/**
 * Implementation of hook_preprocess().
 */
function uc_cc_preprocess(&$variables, $hook) {
  $settings = array(
    'CToolsModal' => array(
      'loadingText' => t('Loading...'),
      'closeText' => t('Close'),
      'modalSize' => array(
        'type' => 'fixed',
        'height' => 500,
        'width' => 500,
      ),
      'modalOptions' => array(
        'opacity' => .6,
        'background-color' => '#000',
      ),
      'animation' => 'fadeIn',
      'animationSpeed' => 'slow',
      'closeImage' => theme('image', array(
        'path' => ctools_image_path('icon-close-window.png'),
        'title' => t('Close window'),
        'alt' => t('Close window'),
      )),
      'throbber' => theme('image', array(
          'path' => ctools_image_path('throbber.gif'),
          'title' => t('Loading...'),
          'alt' => t('Loading'),
      )),
    ),
  );

  drupal_add_js($settings, 'setting');

}

/**
 * Implementation of hook_theme().
 */
function uc_cc_theme($existing, $type, $theme, $path) {
  return array(
    'uc_payment_method_' => array(
      'arguments' => array('form' => NULL),
    ),
  );

}

function cc_refresh_callback(){

    $return = ccApiRefreshCoins();
    return $return;

}

/*
*  Coin Queries
*/


/*
*  Grab User's enabled coin types 
*/
function getAvailableCoins(){
$AllCoin = array();
$ClientCoins = array();
$query = db_select('cc_coins', 'u');
$query->fields('u', array('coin_code', 'coin_name', 'rate', 'coin_confirm', 'coin_image'));
   $result = $query->execute();
	foreach($result as $cn){
		$ClientCoins['coin_code'] = $cn->coin_code;
		$ClientCoins['coin_name'] = $cn->coin_name;
		$ClientCoins['rate'] = $cn->rate;
		$ClientCoins['confirms'] = $cn->coin_confirm;
		$ClientCoins['coin_image'] = $cn->coin_image;
		array_push($AllCoin, $ClientCoins);
	}
return $AllCoin;

}

function checkLastRefresh(){

}

function addCoin($coin_name, $coin_code, $coin_rate){
          try {
              $result = db_merge('cc_coins')
				->key(array('coin_code' => $coin_code))
				->insertFields(array(
                'coin_code' => $coin_code,
				'coin_name' => $coin_name,
				'coin_image' => '/images/'.strtolower($coin_name).'.png',
      			'coin_confirm' => '1',
                'rate' => $coin_rate,
				'timestamp' => '',
              ))
			->updateFields(array(
                'coin_code' => $coin_code,
				'coin_name' => $coin_name,
                'coin_confirm' => '1',
				'rate' => $coin_rate,
				'timestamp' => '',
				))

			 ->execute();
          } catch (exception $e) {

                watchdog('cc_coins', 'Could not insert coin into database: !fault', $e->getMessage());
                return FALSE;
        }
	return true;
}


/*******************************************************************************
 * Callback Functions, Forms, and Tables
 ******************************************************************************/

function ccApiRefreshCoins(){
    checkLastRefresh();
    module_load_include('inc', 'uc_cc', 'includes/cc-php/cc');
    $apikey = variable_get('uc_cc_server_apikey', '');
	$count = 0;
    try {
        $ccApi = new CheckoutCryptoApi();
        $response = $ccApi->query(array('action' => 'refreshcoins','apikey' => $apikey));
    } catch (exception $e) {
        watchdog('uc_cc_ccApiRefreshCoins', 'API query for new order failed: !fault', $e->getMessage());
    }
    if(isset($response['response']['coins'])) {
		foreach($response['response']['coins'] as $coin){
			$coin_name = $coin['coin_name'];
			$coin_code = $coin['coin_code'];
			$coin_rate = $coin['rate'];
			$result = addCoin($coin_name, $coin_code, $coin_rate);
			$count++;
		}
        return $result;
   } else {
        $result['success'] = FALSE;
       return $result;
   }

}

function ccApiNewOrder($request) {
    module_load_include('inc', 'uc_cc', 'includes/cc-php/cc');
    $apikey = variable_get('uc_cc_server_apikey', '');

    try {
        $ccApi = new CheckoutCryptoApi();
        $response = $ccApi->query(array('action' => 'getnewaddress','apikey' => $apikey, 'coin' => $request['coin_name'],'amount' => $request['coin_amount']));
    } catch (exception $e) {
        watchdog('uc_cc_ccApiNewOrder', 'API query for new order failed: !fault', $e->getMessage());
    }
    if(isset($response['response']['queue_id'])) {
        $result['queue_id'] = $response['response']['queue_id'];
        $result['success'] = TRUE;
        return $result;
    } else {
        $result['success'] = FALSE;
       return $result;
    }
}

function ccApiAddressBalance($request) {
    module_load_include('inc', 'uc_cc', 'includes/cc-php/cc');
    $apikey = variable_get('uc_cc_server_apikey', '');

    try {
        $ccApi = new CheckoutCryptoApi();
        $response = $ccApi->query(array('action' => 'getreceivedbyaddress','apikey' => $apikey, 'coin' => $request['coin_name'], 'address' => $request['address'], 'amount' => $request['coin_amount'], 'confirms' => '1'));
    } catch (exception $e) {
        watchdog('uc_cc_ccApiAddressBalance', 'API query for balance failed: !fault', $e->getMessage());
    }

    if(isset($response['response']['orderid'])) {
        $result['queue_id'] = $response['response']['orderid'];
        $result['success'] = TRUE;
        return $result;
    } else {
        $result['success'] = FALSE;
       return $result;
    }
}

function ccApiExchangeRate($request) {
    module_load_include('inc', 'uc_cc', 'includes/cc-php/cc');
    $apikey = variable_get('uc_cc_server_apikey', '');

    try {
        $ccApi = new CheckoutCryptoApi();
        $response = $ccApi->query(array('action' => 'getrate','apikey' => $apikey, 'coin' => $request['coin_name']));
    } catch (exception $e) {
        watchdog('uc_cc_ccApiExchangeRate', 'API query for exchange rate failed: !fault', $e->getMessage());
    }

    if(isset($response['response']['rates'])) {
        $result['rate'] = $response['response']['rates']['USD_'.$request['coin_name']];
        $result['success'] = TRUE;
        return $result;
    } else {
        $result['success'] = FALSE;
       return $result;
    }
}


function ccApiOrderStatus($queue_id, $coin) {
    module_load_include('inc', 'uc_cc', 'includes/cc-php/cc');
    $apikey = variable_get('uc_cc_server_apikey', '');
    try {
        $ccApi = new CheckoutCryptoApi();
        $response = $ccApi->query(array('action' => 'getstatus','apikey' => $apikey, 'orderid' => $queue_id, 'coin' => $coin));
    } catch (exception $e) {
        watchdog('uc_cc_ccApiOrderStatus', 'API query for status failed: !fault', $e->getMessage());
    }
    if(isset($response['response']['status'])) {
        $result['status'] = $response['response']['status'];
        if(isset($response['response']['address'])) {
            $result['address'] = $response['response']['address'];
        } else {
            $result['address'] = FALSE;
        }
        if(isset($response['response']['balance'])) {
            $result['balance'] = $response['response']['balance'];
        } else {
            $result['balance'] = FALSE;
        }
        $result['success'] = TRUE;
        return $result;
    } else {
        $result['success'] = FALSE;
       return $result;
    }
}

function cc_order_status($order) {
    $result = db_select('uc_payment_cc')
      ->fields('uc_payment_cc', array(
        'order_id',
        'cc_coinname_short',
        'cc_coinname_full',
        'cc_coin_amount',
        'cc_address',
        'cc_pay_status',
        'cc_queue_id',
        'cc_queue_id_tmp',
        'cc_pay_amount',
        'timestamp'))
      ->condition('order_id', $order->order_id, '=')
      ->execute()
      ->fetchAssoc();
    if(isset($result)) {
        $time = time();
        $order_time = strtotime($result['timestamp']);
        if($order_time < ($time - 5)) {
            $queue_id = $result['cc_queue_id_tmp'];
            $pay_status = $result['cc_pay_status'];
            switch ($pay_status) {
            case 'registered':
                    $response = ccApiOrderStatus($queue_id, $result['cc_coinname_short']);
                    if(isset($response['address']) AND ($response['address'] != $result['cc_address']))  {
                        $request['balance'] = $result['cc_coin_amount'];
                        $request['address'] = $response['address'];
                        $status = 'pending_payment';
                        $address = $response['address'];

                        try {
                            db_update('uc_payment_cc')
                              ->fields(array(
                                'cc_pay_status' => $status,
                                'cc_address' => $address,
                               ))
                              ->condition('order_id', $order->order_id, '=')
                              ->execute();
                      } catch (exception $e) {
                          watchdog('cc_order_status', 'Could not update order in database: !fault', $e->getMessage());
                      }

                      $result['cc_queue_id'] = $queue_id;
                      $result['cc_pay_status'] = $status;
                      $result['cc_address'] = $response['address'];
                    }
                    break;
                case 'partial_payment_received':
                case 'pending_payment':
                  $response = ccApiOrderStatus($queue_id, $result['cc_coinname_short']);
                  if (isset($response['balance']) AND $response['balance'] != FALSE) {
                      $balance = floatval($response['balance']);
                      if(($balance > floatval('0.00000000'))) {
                          if($balance >= floatval($result['cc_coin_amount'])) {
                              $status = 'payment_received';
                          } else {
                              $status = 'partial_payment_received';
                          }
                      } else {
                          $status = 'pending_payment';
                      }
                      if($status == 'payment_received') {
                          try {
                              $data = 'Currency: '.$result['cc_coinname_full'];
                              $payment_details = uc_payment_enter($result['order_id'], 'checkoutcrypto', $order->order_total, 0, $data, NULL);
                              uc_cart_complete_sale($order);
                              $status = 'payment_entered';
                        } catch (exception $e) {
                                  watchdog('cc_order_status', 'Could not complete sale. !fault', $e->getMessage());
                              }
                      }

                      try {
                          db_update('uc_payment_cc')
                            ->fields(array(
                              'cc_pay_status' => $status,
                              'cc_queue_id_tmp' => $queue_id,
                              'cc_pay_amount' => $balance,
                             ))
                            ->condition('order_id', $order->order_id, '=')
                            ->execute();
                      } catch (exception $e) {
                          watchdog('cc_order_status', 'Could not update order in database: !fault', $e->getMessage());
                      }
                      $result['cc_queue_id'] = $queue_id;
                      $result['cc_pay_status'] = $status;
                      $result['cc_pay_amount'] = $balance;
                  
                    } else {
                        try {
                            $request['address'] = $result['cc_address'];
                            $request['coin_amount'] = $result['cc_coin_amount'];
                            $request['coin_name'] = $result['cc_coinname_short'];
                            $response = ccApiAddressBalance($request);
                            $queue_id = $response['queue_id'];
                            db_update('uc_payment_cc')
                              ->fields(array(
                                'cc_queue_id_tmp' => $queue_id,
                               ))
                              ->condition('order_id', $order->order_id, '=')
                              ->execute();
                        } catch (exception $e) {
                            watchdog('cc_order_status', 'Could not update queue_id in database: fault', $e->getMessage());
                        }
                  }
                  break;

                default:
                  break;
            }
        }
        return $result;
    } else {
        return FALSE;
    }

}

function uc_payment_method_cc($op, &$order, $form = NULL, &$form_state = NULL) {

  switch ($op) {

    case 'cart-review':
        drupal_add_js('sites/all/modules/uc_cc/uc_cc.js', 'file');
        drupal_add_css('sites/all/modules/uc_cc/uc_cc.css', 'file');
        break;

    // Add cc settings to the payment methods settings form.
    case 'settings':
      return uc_cc_settings_form();

    case 'cart-details':
    drupal_add_css('sites/all/modules/uc_cc/uc_cc.css', 'file');

    global $base_path;
    $coins = getAvailableCoins();
    $modp = drupal_get_path('module','uc_cc');

    $payment_form = array();
    $payment_form['cc-notice'] = array(
        '#markup' => '<p>' . t('This store supports cryptocurrency payments, you can pay the current market exchange rate of your order from %currency to any of the accepted currencies, Once the order is confirmed you will receive the address to send to.', array('%currency' => $order->currency)) . '</p>'
    );
    $payment_form['cc-notice-coins-wrapper'] = array('#markup' => '<div id="cc_coin_enabled_wrapper">');
    foreach($coins as $coin){
        $coin_code = strtolower($coin['coin_code']);
        $coin_image = $coin['coin_image'];
        $payment_form['cc-notice-coins'.$coin_code] = array(
            '#markup' => t('<div id="cc_coin_preview_'.$coin_code.'" class="cc_coin_coins_preview"><img src="'.$base_path.$modp.$coin_image.'" width="50" height="50" /></div>')
        );
    }
    $payment_form['cc-notice-coins-wrapper-end'] = array('#markup' => '</div>');

    return $payment_form;

    case 'order-submit':
      $coin_name = $order->cc_coinname_short;
      $coin_name_full = $order->cc_coinname_full;
      $coin_amount = uc_cc_payment_amount_to_coin($order);
      $coin_rate = uc_cc_exchange_rate($order);

      $request = array();
      $request['coin_name'] = $coin_name;
      $request['coin_amount'] = $coin_amount;
      $response = ccApiNewOrder($request);
      if(isset($response['queue_id'])) {
          $queue_id = $response['queue_id'];
      } else {
          return FALSE;
      }
      try {
      $hasOrder = db_select('uc_payment_cc')
        ->fields('uc_payment_cc', array(
          'order_id'))
        ->condition('order_id', $order->order_id, '=')
        ->execute()
        ->fetchAssoc();
      } catch (exception $e) {
        //todo
      }
      if($hasOrder) { //order exists but most likely order attributes needs to be updated
          db_update('uc_payment_cc')
             ->fields(array(
                'cc_pay_status' => 'registered',
                'cc_address' => NULL, //make sure we don't use an address for another coin
                'cc_coinname_short' => $coin_name,
                'cc_coinname_full' => $coin_name_full,
                'cc_coin_amount' => $coin_amount,
                'cc_queue_id_tmp' => $queue_id,
             ))
             ->condition('order_id', $order->order_id, '=')
             ->execute();
      } else { //new order
          try {
              db_insert('uc_payment_cc')->fields(array(
                'order_id' => $order->order_id,
                'exchange_rate' => $coin_rate,
                'cc_coinname_short' => $coin_name,
                'cc_coinname_full' => $coin_name_full,
                'cc_coin_amount' => $coin_amount,
                'cc_queue_id' => $queue_id,
                'cc_queue_id_tmp' => $queue_id,
                'cc_pay_status' => 'registered',
              ))->execute();
          } catch (exception $e) {
                watchdog('uc_payment_method_cc', 'Could not insert order into database: !fault', $e->getMessage());
                return FALSE;
        }
      }

      $return = array('success' => TRUE, 'coin_amount' => $coin_amount, 'queue_id' => $queue_id, 'coin_name' => $coin_name, 'coin_name_full' => $coin_name_full, 'pay_status' => 'registered');
      return $return;
  }
}

/**
 * Convert an orders balance to cryptocurrency
 *
 * @param $order
 */
function uc_cc_payment_amount_to_coin($order) {
  //Check if order exists
  try {
      $result = db_select('uc_payment_cc')
        ->fields('uc_payment_cc', array(
          'cc_coinname_short',
          'cc_coin_amount'))
        ->condition('order_id', $order->order_id, '=')
        ->condition('cc_coinname_short', $order->cc_coinname_short, '=')
        ->execute()
        ->fetchAssoc();
  } catch (exception $e) {
      watchdog('uc_cc_payment_amount_to_coin', 'Could not query database: !fault', $e->getMessage());
  }

  //Don't calculate new rate if cc_coin_amount is already set and coin is the same
  if(isset($result['cc_coin_amount']) AND ($order->cc_coinname_short == $result['cc_coinname_short'])) {
    return $result['cc_coin_amount'];
  } else {
    //Get current exchange rate
    $rate = uc_cc_exchange_rate($order);
    $coin_total = round($order->order_total / $rate, 4, PHP_ROUND_HALF_UP);
    return $coin_total;
  }

  return FALSE;
}

function uc_cc_exchange_rate($order) {

  $enabled_coins = array();
  $coins = getAvailableCoins();
  foreach($coins as $coin) {
    $enabled_coins[] = strtoupper($coin['coin_code']);
  }

  try {
     $result = db_select('cc_coins')
        ->fields('cc_coins', array(
          'coin_code',
          'rate'))
        ->condition('coin_code', $order->cc_coinname_short, '=')
        ->condition('timestamp', (time()-900), '>=') //cache no more than 15 min
        ->range(0,1)
        ->execute()
        ->fetchAssoc();
  } catch (exception $e) {
      watchdog('uc_cc_exchange_rate', 'Could not query database: !fault', $e->getMessage());
  }

  //Return cached exchange rate if there is one
  if(isset($result['rate'])) {
    return $result['rate'];
  } else {
      //Get current exchange rate from CheckoutCrypto
      if(isset($order->cc_coinname_short)) {
          $request['coin_name'] = $order->cc_coinname_short;
      } else {
          watchdog('uc_cc_exchange_rate', 'Unable to determine coin', WATCHDOG_ERROR);
          return FALSE; //coin could not be determined
      }
      $response = ccApiExchangeRate($request);
      $rate = $response['rate'];
      try {
          db_update('cc_coins')->fields(array(
              'rate' => $rate,
              'timestamp' => time(),
          ))
          ->condition('coin_code', $order->cc_coinname_short, '=')
          ->execute();
      } catch (exception $e) {
          watchdog('uc_cc_exchange_rate', 'Could not update database: !fault', $e->getMessage());
      }
  }

  if (!$rate || !is_numeric($rate)) {
    watchdog('uc_cc_exchange_rate', 'Unable to get current exchange rate', WATCHDOG_ERROR);
    $rate = FALSE;
  }
  return $rate;
}

function uc_cc_entity_load($entities, $type) {
  if ($type == 'uc_order') {
    foreach ($entities as $entity) {
      $entity->cc_payment = db_select('uc_payment_cc', 'u')
        ->fields('u', array('cc_address', 'exchange_rate','cc_coinname_short','cc_coinname_full'))
        ->condition('order_id', $entity->order_id)
        ->execute()
        ->fetchAssoc();
    }
  }
}

/**
 * Implementation of hook_theme_registry_alter()
 */
function uc_cc_theme_registry_alter(&$registry) {
  $registry['uc_order']['process functions'][]='uc_cc_postprocess_invoice_themer';
}

/**
 * Modify Payment method and insert the order payment information
 * @param $variables
 * @param $hook
 */
function uc_cc_postprocess_invoice_themer(&$variables, $hook) {
    if ($variables['order']->payment_method == 'checkoutcrypto' && !empty($variables['order']->cc_payment)) {

    $result = db_select('uc_payment_cc')
      ->fields('uc_payment_cc', array(
        'order_id',
        'cc_coinname_short',
        'cc_coinname_full',
        'cc_address',
        'cc_pay_amount',
        'timestamp'))
      ->condition('order_id', $order->order_id, '=')
      ->execute()
      ->fetchAssoc();

    $coin_name = $result['cc_coinname_short'];
    $coin_address = $result['cc_address'];
    $coin_amount = $result['cc_pay_amount'];
    $variables['order_payment_method'] = t("CheckoutCrypto: !coin !amount paid to !address", array(
      '!coin' => $coin_name,
      '!amount' => $coin_amount,
      '!address' => $coin_address
    ));
  }
}

/*******************************************************************************
 * cc functions and utility functions
 ******************************************************************************/

/**
 * Check for and try to process pending cc transactions.
 */
function uc_cc_cron($order = NULL) {
  if($order) {
      //run this order
  }

  // Default to an hourly interval. Of course, cron has to be running at least
  // hourly for this to work.
  $interval = 10;
  // We usually don't want to act every time cron runs (which could be every
  // minute) so keep a time for the next run in a variable.
  if (time() >= variable_get('cron_example_next_execution', 0)) {
    // This is a silly example of a cron job.
    // It just makes it obvious that the job has run without
    // making any changes to your database.
    watchdog('uc_cc_cron', 'uc_cc_cron was executed');
    if (!empty($GLOBALS['cron_example_show_status_message'])) {
      drupal_set_message(t('cron_example executed at %time', array('%time' => date_iso8601(time(0)))));
    }
    variable_set('cron_example_next_execution', time() + $interval);
  }
}
